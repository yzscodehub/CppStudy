### 进程与线程
####    进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。
进程是系统进行资源分配和调度的一个独立单位。

####    线程
线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器、一组寄存器和栈),
但是它可与同属于一个进程的其他线程共享进程所拥有的的全部资源。

一个线程可以创建和撤销另一个线程；同一个进程中多个线程之间可以并发执行。

相对于进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。

#####   优缺点
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而线程正相反。同时，线程适合在SMP(对此多处理)机器上，而进程则可以跨机器迁移。

####    进程与线程的区别
进程是系统资源分配的基本单位，而线程是任务调度和程序执行的基本单位。
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。
线程有自己的堆栈和局部变量，线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，
但在进程切换时，耗费资源较大，效率也槽差一些。
但是对于一些要求同时进行并且又要共享某些变量的并发操作，只能使用线程，不能用进程。
1. 简而言之，一个程序至少有一个进程，一个进程至少有一个线程，进程是线程的容器，不存在没有线程的进程。
2. 线程的划分尺度小于进程，使用多线程程序的并发性高。
3. 进程执行过程中拥有独立的内存单元，而多线程共享内存，从而极大地提高了程序的运行效率。
4. 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。
线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5. 从逻辑角度看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。
    但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源的分配。这就是进程和线程的重要区别。
    
####    多线程与多线程
进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。
显然，程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。
而进程则不同，它是程序在某个数据集上的执行，它一个动态实体。
它因创建而产生，因调度而运行，因等待资源或事假而被处于等待状态，因完成任务而被撤销，反应了一个程序在一定数据集上的全部动态过程。
进程是操作系统分配资源的基本单位。在Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。
线程是进程的一个实体，是CPU调度和分派的基本单位。
线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

线程和进程的关系：线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间。
当进程退出时，该进程所产生的所有线程都会被强制退出并清除。
线程可与属于同一进程的其他线程共享改进程所拥有的全部地址空间，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息（如程序计数器、一组寄存器和栈）。

在同一时间里，如果一个计算机系统中允许两个或两个以上的进程处于运行状态，这便是多任务。
现代的操作几乎都是多任务操作系统，能够同时管理多个进程的运行。
多任务带来的好处是明显的。比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任务之间丝毫不会相互干扰。
那么这里就涉及到并行的问题，俗话说，一心不能二用，这对计算机也一样，原则上一个CPU只能分配给一个进程，以便运行这个进程。
如果计算机中只有一个 CPU，也就是说只有一颗心脏，要让它一心多用，同时运行多个进程，就必须使用并发技术。
实现并发技术相当复杂，最容易理解的是“时间片轮询进程调度算法”，它的思想简单介绍就是：在操作系统的管理下，所有正在运行的进程轮流使用CPU，
每个进程运行占用CPU的时间风非常短(比如10毫秒)，这样用户是根本感觉不出来CPU是在轮流为多个进程服务，就好像所有的进程都在不间断的运行一样。
但实际上在任何一个时间内有且仅有一个进程占用CPU。

如果一台计算机上有多个CPU，情况就不同了，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进程就是真正同时运行的，这便是并行。
但如果进程数大于CPU数，则仍然需要使用并发技术。

在Windows中，进行CPU分配是以线程为单位的，一个进程可能由多个线程组成，这时情况可能更加复杂，但简单来说，有如下关系：
> 总线程数 <= CPU数量：并行运行

> 总线程数 >= CPU数量：并发运行

并行运行的效率显然要高于并发运行，所以在多CPU中，多任务的效率比较高；但是如果在多CPU计算机中只运行一个进程(线程), 就不能发挥多CPU的优势。

多任务操作系统(如Windows)的基本原理：操作系统将CPU的时间片分配给多个线程，每个线程在操作系统指定的时间片内完成(注意这里的多线程是分属于不同进程的)。
操作系统不断的从一个线程的执行切换到另一个线程的执行，如此反复，宏观上看来，就好像是多个线程在一起执行。
由于这多个线程分属于不同的进程，因此在我们看来，就好像是多个进程在同时执行，这样就实现了多任务。

#####   引入线程带来的好处
1. 在进程内创建、终止线程比创建、终止进程快。
2. 同一进程内的线程间切换比进程间的切换要快，尤其是用户级线程间的切换。

#####   根据进程与线程的设置，操作系统大致分为如下类型
1. 单进程、单线程，MS-DOS大致是这种操作系统；
2. 多进程、单线程，多数UNIX(及类UNIX的LINUX)是这种操作系统；
3. 多进程、多线程，Win32(Windows NT/2000/XP等)、Solaris 2.x和OS/2都是这种操作系统；
4. 单进程、多线程，VxWorks是这种操作系统。

### 进程间通信
进程是计算机系统分配资源的最小单位。

####    无名管道pipe
管道是一种最基本的IPC通信，作用于有亲缘关系的进程间，完成数据传递。调用pipe系统函数即可创建一个管道。

特点：
1. 本质是一个伪文件(实为内核缓冲区)
2. 由两个文件描述符引用，一个表示读端，一个表示写端
3. 规定数据从管道的写端流入管道，从读端流出

管道的原理：管道实为内核使用环形队列机制，借助内核缓冲区(4K)实现。

管道的局限性：
1. 由于管道采用半双工通信方式，因此，数据只能在一个方向上流动；
2. 只能在有公共祖先的进程间使用管道；
3. 数据一旦被读便不再存在于管道中。
pipe函数：
```
函数形式：int pipe(int fd[2]);
功能：创建管道，为系统调用unistd.h
参数：就是得到的文件描述符，可见有两个文件描述符：fd[0]和fd[1],管道有一个读端fd[0]和一个写端fd[1]。
返回值：成功0，失败-1
```
向管道文件读写数据其实在读写内核缓冲区。

```
int main(){
	pid_t pid;
	int fd[2];
	char buf[512];
	if(pipe(fd) == -1){
		sys_err("pipe");
	}
	pid  = fork();
	if(pid == 0){
		close(fd[1]);
		printf("child process read data\n");
		int len = read(fd[0], buf, sizeof(buf));
		write(stdout, buf, len);
		close(fd[0]);
	}
	else{
		close(fd[0]);
		write(fd[1], data, strlen(data));
		printf("parents process write data\n");
		wait(NULL);
		close(fd[1]);
	}
	return 0;
}
```

####    有名管道FIFO
有名管道解决了无名管道只能在有亲缘关系进程之间通信的缺点。

FIFO是Linux基础文件类型中的一种，但是，FIFO文件在磁盘上没有数据，仅仅用来标识内核中的一条通道。
各进程可以这个文件进行read/write,实际上就是在读写内核通道，这样就实现了进程间的通信。


> int mkfifo(const char* pathname, mode_t mode); 成功返回0，失败-1

一旦使用mkfifo创建了FIFO，就可以使用文件 I/O 函数操作FIFO。




笔记整理自：
https://blog.csdn.net/mxsgoden/article/details/8821936#comments
https://blog.csdn.net/qq_40025335/article/details/99717423
